<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>yggdrasil</title>
</head>

<body>
  <div id="ui">
    <div class="scroll" tabindex="0" aria-label="Profile sections" style="scrollbar-width: none; overflow-y: scroll;">
      <section class="card primary">
        <h2>Ryan — Creative Software Engineer (Primary)</h2>
        <p>Interactive graphics, realtime systems, and WebGL experiments. I build visual systems, demos, and production
          tools that explore realtime rendering and expressive UX.</p>
      </section>
      <section class="card">
        <h2>Projects — Interactive Visuals</h2>
        <p>Portfolio of realtime visual systems, demos, and generative art. Technologies include WebGL, three.js, GLSL,
          and Web Audio.</p>
        <button class="back">Back to Top</button>
      </section>
      <section class="card">
        <h2>Projects — Tools &amp; Infrastructure</h2>
        <p>Tools for content pipelines, build/test automation, and small engines for rapid prototyping and deployment.
        </p>
        <button class="back">Back to Top</button>
      </section>
      <section class="card">
        <h2>Research &amp; Experiments</h2>
        <p>Sketches exploring procedural generation, physically-inspired motion, and data-driven visuals.</p>
        <button class="back">Back to Top</button>
      </section>
      <section class="card">
        <h2>Open Source</h2>
        <p>Selected contributions and libraries with active maintenance and clear documentation. Emphasis on usability
          and performance.</p>
        <button class="back">Back to Top</button>
      </section>
      <section class="card">
        <h2>Writing</h2>
        <p>Longer notes, technical writeups, and essays about rendering, architecture, and tradeoffs made while shipping
          projects.</p>
        <button class="back">Back to Top</button>
      </section>
      <section class="card">
        <h2>Speaking &amp; Workshops</h2>
        <p>Talks and workshop materials on WebGL, realtime graphics, and building interactive prototypes.</p>
        <button class="back">Back to Top</button>
      </section>
      <section class="card">
        <h2>About</h2>
        <p>Background, interests, and a short CV summary. I enjoy building systems that encourage playful exploration
          and polish.</p>
        <button class="back">Back to Top</button>
      </section>
      <section class="card">
        <h2>Contact</h2>
        <p>Get in touch: <a href="mailto:you@example.com">you@example.com</a> — or view code at <a
            href="https://github.com/sintfoap" target="_blank" rel="noopener">GitHub</a>.</p>
        <button class="back">Back to Top</button>
      </section>
    </div>
  </div>

  <canvas id="bg"></canvas>
  <script>
    // stiff snap-scrolling for the `#ui .scroll` element
    (function () {
      const container = document.querySelector('#ui .scroll');
      if (!container) return;
      // ensure we rely on CSS for overflow behavior (avoid overriding scrollbar layout)
      let isLocked = false;
      let index = 0;
      const cards = Array.from(container.querySelectorAll('.card'));
      function layout() {
        // size each card to the visible container height so snaps are exact
        const vh = container.clientHeight;
        cards.forEach(c => {
          c.style.height = vh + 'px';
          c.style.boxSizing = 'border-box';
        });
        // clamp index
        index = Math.max(0, Math.min(index, cards.length - 1));
        // align to the current card's exact offset (use actual offsetTop)
        const target = cards[index] ? Math.round(cards[index].offsetTop) : Math.round(index * vh);
        container.scrollTop = target;
      }
      window.addEventListener('resize', layout);
      layout();
      // animator for precise control over scrolling (avoids partial browser smooth behavior)
      function animateScrollTo(target, duration = 480) {
        return new Promise((resolve) => {
          const start = container.scrollTop;
          const delta = target - start;
          if (Math.abs(delta) < 0.5) { container.scrollTop = target; resolve(); return; }
          const startTime = performance.now();
          // smoother ease-in-out cubic
          function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
          function step(now) {
            const t = Math.min(1, (now - startTime) / duration);
            const eased = easeInOutCubic(t);
            container.scrollTop = start + delta * eased;
            if (t < 1) requestAnimationFrame(step);
            else { container.scrollTop = target; resolve(); }
          }
          requestAnimationFrame(step);
        });
      }

      async function snapTo(i) {
        if (isLocked) return;
        isLocked = true;
        index = Math.max(0, Math.min(i, cards.length - 1));
        const target = cards[index] ? Math.round(cards[index].offsetTop) : Math.round(index * container.clientHeight);
        // clear wheel accumulator when we initiate a snap
        wheelAccum = 0;
        // attempt to trigger camera transition for this section (if main.js exposed the function)
        try { if (window.moveCameraToSection) window.moveCameraToSection(index); } catch (e) { }
        // temporarily block input that could interrupt the snapping
        const block = (e) => { e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); return false; };
        window.addEventListener('wheel', block, { passive: false, capture: true });
        window.addEventListener('touchmove', block, { passive: false, capture: true });
        window.addEventListener('keydown', block, { passive: false, capture: true });
        try {
          await animateScrollTo(target, 360);
        } finally {
          // remove temporary blockers after animation completes
          window.removeEventListener('wheel', block, { capture: true });
          window.removeEventListener('touchmove', block, { capture: true });
          window.removeEventListener('keydown', block, { capture: true });
          // small delay to keep state stable
          setTimeout(() => { isLocked = false; }, 80);
        }
      }
      // expose snap to global so external scripts (e.g. three.js scene) can trigger UI snaps
      window.snapToSection = function (i) { snapTo(i); };
      // wire 'Overview' buttons in each section to snap back to primary (index 0)
      try {
        const backButtons = Array.from(document.querySelectorAll('.card .back'));
        backButtons.forEach(b => b.addEventListener('click', (ev) => {
          ev.preventDefault(); ev.stopPropagation();
          try { if (window.snapToSection) window.snapToSection(0); } catch (e) { }
          try { if (window.moveCameraToSection) window.moveCameraToSection(0); } catch (e) { }
        }));
      } catch (e) { }
      // wheel accumulation to handle small delta events that should sum to a full page
      let wheelAccum = 0;
      let wheelTimeout = null;
      const wheelThreshold = 16; // accumulate until crossing this value
      container.addEventListener('wheel', (ev) => {
        if (isLocked) { ev.preventDefault(); return; }
        ev.preventDefault();
        wheelAccum += ev.deltaY;
        clearTimeout(wheelTimeout);
        wheelTimeout = setTimeout(() => { wheelAccum = 0; }, 150);
        if (wheelAccum > wheelThreshold) { wheelAccum = 0; snapTo(index + 1); }
        else if (wheelAccum < -wheelThreshold) { wheelAccum = 0; snapTo(index - 1); }
      }, { passive: false });
      // keyboard navigation
      container.addEventListener('keydown', (ev) => {
        if (ev.key === 'ArrowDown' || ev.key === 'PageDown') { ev.preventDefault(); snapTo(index + 1); }
        if (ev.key === 'ArrowUp' || ev.key === 'PageUp') { ev.preventDefault(); snapTo(index - 1); }
        if (ev.key === 'Home') { ev.preventDefault(); snapTo(0); }
        if (ev.key === 'End') { ev.preventDefault(); snapTo(cards.length - 1); }
      });
      // touch support: detect swipe vertical
      let touchStartY = 0;
      container.addEventListener('touchstart', (e) => { touchStartY = e.touches[0].clientY; }, { passive: true });
      container.addEventListener('touchend', (e) => {
        const dy = (e.changedTouches[0].clientY - touchStartY) * -1;
        if (Math.abs(dy) > 36) {
          if (dy > 0) snapTo(index + 1); else snapTo(index - 1);
        }
      });
    })();
  </script>

  <script type="module" src="/src/main.js"></script>
</body>

</html>